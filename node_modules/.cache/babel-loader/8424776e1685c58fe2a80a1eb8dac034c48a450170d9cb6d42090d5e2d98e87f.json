{"ast":null,"code":"/**\r\n * Helpers to convert the change Payload into native JS types.\r\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n(function (PostgresTypes) {\n  PostgresTypes[\"abstime\"] = \"abstime\";\n  PostgresTypes[\"bool\"] = \"bool\";\n  PostgresTypes[\"date\"] = \"date\";\n  PostgresTypes[\"daterange\"] = \"daterange\";\n  PostgresTypes[\"float4\"] = \"float4\";\n  PostgresTypes[\"float8\"] = \"float8\";\n  PostgresTypes[\"int2\"] = \"int2\";\n  PostgresTypes[\"int4\"] = \"int4\";\n  PostgresTypes[\"int4range\"] = \"int4range\";\n  PostgresTypes[\"int8\"] = \"int8\";\n  PostgresTypes[\"int8range\"] = \"int8range\";\n  PostgresTypes[\"json\"] = \"json\";\n  PostgresTypes[\"jsonb\"] = \"jsonb\";\n  PostgresTypes[\"money\"] = \"money\";\n  PostgresTypes[\"numeric\"] = \"numeric\";\n  PostgresTypes[\"oid\"] = \"oid\";\n  PostgresTypes[\"reltime\"] = \"reltime\";\n  PostgresTypes[\"text\"] = \"text\";\n  PostgresTypes[\"time\"] = \"time\";\n  PostgresTypes[\"timestamp\"] = \"timestamp\";\n  PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n  PostgresTypes[\"timetz\"] = \"timetz\";\n  PostgresTypes[\"tsrange\"] = \"tsrange\";\n  PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\r\n * Takes an array of columns and an object of string values then converts each string value\r\n * to its mapped type.\r\n *\r\n * @param {{name: String, type: String}[]} columns\r\n * @param {Object} record\r\n * @param {Object} options The map of various options that can be applied to the mapper\r\n * @param {Array} options.skipTypes The array of types that should not be converted\r\n *\r\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\r\n * //=>{ first_name: 'Paul', age: 33 }\r\n */\nexport const convertChangeData = (columns, record, options = {}) => {\n  var _a;\n  const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n    return acc;\n  }, {});\n};\n/**\r\n * Converts the value of an individual column.\r\n *\r\n * @param {String} columnName The column that you want to convert\r\n * @param {{name: String, type: String}[]} columns All of the columns\r\n * @param {Object} record The map of string values\r\n * @param {Array} skipTypes An array of types that should not be converted\r\n * @return {object} Useless information\r\n *\r\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\r\n * //=> 33\r\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\r\n * //=> \"33\"\r\n */\nexport const convertColumn = (columnName, columns, record, skipTypes) => {\n  const column = columns.find(x => x.name === columnName);\n  const colType = column === null || column === void 0 ? void 0 : column.type;\n  const value = record[columnName];\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value);\n  }\n  return noop(value);\n};\n/**\r\n * If the value of the cell is `null`, returns null.\r\n * Otherwise converts the string value to the correct type.\r\n * @param {String} type A postgres column type\r\n * @param {String} value The cell value\r\n *\r\n * @example convertCell('bool', 't')\r\n * //=> true\r\n * @example convertCell('int8', '10')\r\n * //=> 10\r\n * @example convertCell('_int4', '{1,2,3,4}')\r\n * //=> [1,2,3,4]\r\n */\nexport const convertCell = (type, value) => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length);\n    return toArray(value, dataType);\n  }\n  // If not null, convert to correct type.\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value);\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value);\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value);\n    case PostgresTypes.timestamp:\n      return toTimestampString(value);\n    // Format to be consistent with PostgREST\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value);\n    default:\n      // Return the value for remaining types\n      return noop(value);\n  }\n};\nconst noop = value => {\n  return value;\n};\nexport const toBoolean = value => {\n  switch (value) {\n    case 't':\n      return true;\n    case 'f':\n      return false;\n    default:\n      return value;\n  }\n};\nexport const toNumber = value => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value);\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue;\n    }\n  }\n  return value;\n};\nexport const toJson = value => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`);\n      return value;\n    }\n  }\n  return value;\n};\n/**\r\n * Converts a Postgres Array into a native JS array\r\n *\r\n * @example toArray('{}', 'int4')\r\n * //=> []\r\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\r\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\r\n * @example toArray([1,2,3,4], 'int4')\r\n * //=> [1,2,3,4]\r\n */\nexport const toArray = (value, type) => {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  const lastIdx = value.length - 1;\n  const closeBrace = value[lastIdx];\n  const openBrace = value[0];\n  // Confirm value is a Postgres array by checking curly brackets\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr;\n    const valTrim = value.slice(1, lastIdx);\n    // TODO: find a better solution to separate Postgres array data\n    try {\n      arr = JSON.parse('[' + valTrim + ']');\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : [];\n    }\n    return arr.map(val => convertCell(type, val));\n  }\n  return value;\n};\n/**\r\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\r\n * See https://github.com/supabase/supabase/issues/18\r\n *\r\n * @example toTimestampString('2019-09-10 00:00:00')\r\n * //=> '2019-09-10T00:00:00'\r\n */\nexport const toTimestampString = value => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T');\n  }\n  return value;\n};\nexport const httpEndpointURL = socketUrl => {\n  let url = socketUrl;\n  url = url.replace(/^ws/i, 'http');\n  url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n  return url.replace(/\\/+$/, '') + '/api/broadcast';\n};","map":{"version":3,"names":["PostgresTypes","convertChangeData","columns","record","options","skipTypes","_a","Object","keys","reduce","acc","rec_key","convertColumn","columnName","column","find","x","name","colType","type","value","includes","convertCell","noop","charAt","dataType","slice","length","toArray","bool","toBoolean","float4","float8","int2","int4","int8","numeric","oid","toNumber","json","jsonb","toJson","timestamp","toTimestampString","abstime","date","daterange","int4range","int8range","money","reltime","text","time","timestamptz","timetz","tsrange","tstzrange","parsedValue","parseFloat","Number","isNaN","JSON","parse","error","console","log","lastIdx","closeBrace","openBrace","arr","valTrim","_","split","map","val","replace","httpEndpointURL","socketUrl","url"],"sources":["C:\\projects\\cidika-travel\\node_modules\\@supabase\\realtime-js\\src\\lib\\transformers.ts"],"sourcesContent":["/**\r\n * Helpers to convert the change Payload into native JS types.\r\n */\r\n\r\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\r\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\r\n\r\nexport enum PostgresTypes {\r\n  abstime = 'abstime',\r\n  bool = 'bool',\r\n  date = 'date',\r\n  daterange = 'daterange',\r\n  float4 = 'float4',\r\n  float8 = 'float8',\r\n  int2 = 'int2',\r\n  int4 = 'int4',\r\n  int4range = 'int4range',\r\n  int8 = 'int8',\r\n  int8range = 'int8range',\r\n  json = 'json',\r\n  jsonb = 'jsonb',\r\n  money = 'money',\r\n  numeric = 'numeric',\r\n  oid = 'oid',\r\n  reltime = 'reltime',\r\n  text = 'text',\r\n  time = 'time',\r\n  timestamp = 'timestamp',\r\n  timestamptz = 'timestamptz',\r\n  timetz = 'timetz',\r\n  tsrange = 'tsrange',\r\n  tstzrange = 'tstzrange',\r\n}\r\n\r\ntype Columns = {\r\n  name: string // the column name. eg: \"user_id\"\r\n  type: string // the column type. eg: \"uuid\"\r\n  flags?: string[] // any special flags for the column. eg: [\"key\"]\r\n  type_modifier?: number // the type modifier. eg: 4294967295\r\n}[]\r\n\r\ntype BaseValue = null | string | number | boolean\r\ntype RecordValue = BaseValue | BaseValue[]\r\n\r\ntype Record = {\r\n  [key: string]: RecordValue\r\n}\r\n\r\n/**\r\n * Takes an array of columns and an object of string values then converts each string value\r\n * to its mapped type.\r\n *\r\n * @param {{name: String, type: String}[]} columns\r\n * @param {Object} record\r\n * @param {Object} options The map of various options that can be applied to the mapper\r\n * @param {Array} options.skipTypes The array of types that should not be converted\r\n *\r\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\r\n * //=>{ first_name: 'Paul', age: 33 }\r\n */\r\nexport const convertChangeData = (\r\n  columns: Columns,\r\n  record: Record,\r\n  options: { skipTypes?: string[] } = {}\r\n): Record => {\r\n  const skipTypes = options.skipTypes ?? []\r\n\r\n  return Object.keys(record).reduce((acc, rec_key) => {\r\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes)\r\n    return acc\r\n  }, {} as Record)\r\n}\r\n\r\n/**\r\n * Converts the value of an individual column.\r\n *\r\n * @param {String} columnName The column that you want to convert\r\n * @param {{name: String, type: String}[]} columns All of the columns\r\n * @param {Object} record The map of string values\r\n * @param {Array} skipTypes An array of types that should not be converted\r\n * @return {object} Useless information\r\n *\r\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\r\n * //=> 33\r\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\r\n * //=> \"33\"\r\n */\r\nexport const convertColumn = (\r\n  columnName: string,\r\n  columns: Columns,\r\n  record: Record,\r\n  skipTypes: string[]\r\n): RecordValue => {\r\n  const column = columns.find((x) => x.name === columnName)\r\n  const colType = column?.type\r\n  const value = record[columnName]\r\n\r\n  if (colType && !skipTypes.includes(colType)) {\r\n    return convertCell(colType, value)\r\n  }\r\n\r\n  return noop(value)\r\n}\r\n\r\n/**\r\n * If the value of the cell is `null`, returns null.\r\n * Otherwise converts the string value to the correct type.\r\n * @param {String} type A postgres column type\r\n * @param {String} value The cell value\r\n *\r\n * @example convertCell('bool', 't')\r\n * //=> true\r\n * @example convertCell('int8', '10')\r\n * //=> 10\r\n * @example convertCell('_int4', '{1,2,3,4}')\r\n * //=> [1,2,3,4]\r\n */\r\nexport const convertCell = (type: string, value: RecordValue): RecordValue => {\r\n  // if data type is an array\r\n  if (type.charAt(0) === '_') {\r\n    const dataType = type.slice(1, type.length)\r\n    return toArray(value, dataType)\r\n  }\r\n\r\n  // If not null, convert to correct type.\r\n  switch (type) {\r\n    case PostgresTypes.bool:\r\n      return toBoolean(value)\r\n    case PostgresTypes.float4:\r\n    case PostgresTypes.float8:\r\n    case PostgresTypes.int2:\r\n    case PostgresTypes.int4:\r\n    case PostgresTypes.int8:\r\n    case PostgresTypes.numeric:\r\n    case PostgresTypes.oid:\r\n      return toNumber(value)\r\n    case PostgresTypes.json:\r\n    case PostgresTypes.jsonb:\r\n      return toJson(value)\r\n    case PostgresTypes.timestamp:\r\n      return toTimestampString(value) // Format to be consistent with PostgREST\r\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.daterange:\r\n    case PostgresTypes.int4range:\r\n    case PostgresTypes.int8range:\r\n    case PostgresTypes.money:\r\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.text:\r\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.tsrange:\r\n    case PostgresTypes.tstzrange:\r\n      return noop(value)\r\n    default:\r\n      // Return the value for remaining types\r\n      return noop(value)\r\n  }\r\n}\r\n\r\nconst noop = (value: RecordValue): RecordValue => {\r\n  return value\r\n}\r\nexport const toBoolean = (value: RecordValue): RecordValue => {\r\n  switch (value) {\r\n    case 't':\r\n      return true\r\n    case 'f':\r\n      return false\r\n    default:\r\n      return value\r\n  }\r\n}\r\nexport const toNumber = (value: RecordValue): RecordValue => {\r\n  if (typeof value === 'string') {\r\n    const parsedValue = parseFloat(value)\r\n    if (!Number.isNaN(parsedValue)) {\r\n      return parsedValue\r\n    }\r\n  }\r\n  return value\r\n}\r\nexport const toJson = (value: RecordValue): RecordValue => {\r\n  if (typeof value === 'string') {\r\n    try {\r\n      return JSON.parse(value)\r\n    } catch (error) {\r\n      console.log(`JSON parse error: ${error}`)\r\n      return value\r\n    }\r\n  }\r\n  return value\r\n}\r\n\r\n/**\r\n * Converts a Postgres Array into a native JS array\r\n *\r\n * @example toArray('{}', 'int4')\r\n * //=> []\r\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\r\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\r\n * @example toArray([1,2,3,4], 'int4')\r\n * //=> [1,2,3,4]\r\n */\r\nexport const toArray = (value: RecordValue, type: string): RecordValue => {\r\n  if (typeof value !== 'string') {\r\n    return value\r\n  }\r\n\r\n  const lastIdx = value.length - 1\r\n  const closeBrace = value[lastIdx]\r\n  const openBrace = value[0]\r\n\r\n  // Confirm value is a Postgres array by checking curly brackets\r\n  if (openBrace === '{' && closeBrace === '}') {\r\n    let arr\r\n    const valTrim = value.slice(1, lastIdx)\r\n\r\n    // TODO: find a better solution to separate Postgres array data\r\n    try {\r\n      arr = JSON.parse('[' + valTrim + ']')\r\n    } catch (_) {\r\n      // WARNING: splitting on comma does not cover all edge cases\r\n      arr = valTrim ? valTrim.split(',') : []\r\n    }\r\n\r\n    return arr.map((val: BaseValue) => convertCell(type, val))\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\r\n * See https://github.com/supabase/supabase/issues/18\r\n *\r\n * @example toTimestampString('2019-09-10 00:00:00')\r\n * //=> '2019-09-10T00:00:00'\r\n */\r\nexport const toTimestampString = (value: RecordValue): RecordValue => {\r\n  if (typeof value === 'string') {\r\n    return value.replace(' ', 'T')\r\n  }\r\n\r\n  return value\r\n}\r\n\r\nexport const httpEndpointURL = (socketUrl: string): string => {\r\n  let url = socketUrl\r\n  url = url.replace(/^ws/i, 'http')\r\n  url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '')\r\n  return url.replace(/\\/+$/, '') + '/api/broadcast'\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}